use crate::util::util::load_input;
use crate::{Solution, SolutionPair};
use std::collections::{HashMap, HashSet};
use std::str::Lines;
use std::usize;

fn mix(a: u64, b: u64) -> u64 {
    a ^ b
}

fn prune(val: u64) -> u64 {
    val % 16777216
}

fn iterate_secret(secret: u64) -> u64 {
    let mult = secret as u64 * 64;
    let mut secret = mix(secret, mult);
    secret = prune(secret);
    let div = secret / 32;
    secret = mix(secret, div);
    secret = prune(secret);
    let mult2 = secret * 2048;
    secret = mix(secret, mult2);
    secret = prune(secret);
    secret
}

fn n_iterations(mut secret: u64, n: usize) -> u64 {
    for _ in 0..n {
        secret = iterate_secret(secret);
    }
    secret
}

// For each buyer, simulate the creation of 2000 new secret numbers.
// What is the sum of the 2000th secret number generated by each buyer?
fn part_1(lines: Lines) -> u64 {
    lines
        .map(|line| n_iterations(line.parse().expect("Could not parse secret number"), 2000))
        .sum()
}

// Figure out the best sequence to tell the monkey so that by looking for
// that same sequence of changes in every buyer's future prices,
// you get the most bananas in total. What is the most bananas you can get?
fn part_2(lines: Lines) -> i32 {
    let n = 2000;
    // Keep count of each sequence encountered and the total value if chosen
    let mut sequences: HashMap<[i32; 4], i32> = HashMap::new();

    for line in lines {
        let mut seq: Vec<(u64, i32, i32)> = Vec::with_capacity(n);
        let first_secret = line.parse().expect("Could not parse secret number");
        let first_price = (first_secret % 10) as i32;
        seq.push((first_secret, first_price, 0));

        for i in 0..n {
            let (prev_secret, prev_value, _) = seq[i];
            let next_secret = iterate_secret(prev_secret);
            let next_value = (next_secret % 10) as i32;
            let diff = next_value - prev_value;
            seq.push((next_secret, next_value, diff));
        }

        // Each monkey will only sell once, the first time the sequence is encountered
        let mut monkey_sequences: HashSet<[i32; 4]> = HashSet::new();
        for w in seq.windows(4) {
            let sequence = [w[3].2, w[2].2, w[1].2, w[0].2];
            if monkey_sequences.insert(sequence) {
                *sequences.entry(sequence).or_default() += w[3].1;
            }
        }
    }

    *sequences.values().max().unwrap()
}

pub fn solve() -> SolutionPair {
    let input = load_input("inputs/2024/day_22");
    (
        Solution::from(part_1(input.lines())),
        Solution::from(part_2(input.lines())),
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    const EXAMPLE_INPUT: &str = "1
10
100
2024";

    const EXAMPLE_INPUT_2: &str = "1
2
3
2024";

    #[test]
    fn test_n_iterations() {
        assert_eq!(n_iterations(123, 1), 15887950);
        assert_eq!(n_iterations(123, 2), 16495136);
        assert_eq!(n_iterations(123, 3), 527345);
        assert_eq!(n_iterations(123, 4), 704524);
        assert_eq!(n_iterations(123, 5), 1553684);
        assert_eq!(n_iterations(123, 6), 12683156);
        assert_eq!(n_iterations(123, 7), 11100544);
        assert_eq!(n_iterations(123, 8), 12249484);
        assert_eq!(n_iterations(123, 9), 7753432);
        assert_eq!(n_iterations(123, 10), 5908254);
        assert_eq!(n_iterations(1, 2000), 8685429);
        assert_eq!(n_iterations(10, 2000), 4700978);
        assert_eq!(n_iterations(100, 2000), 15273692);
        assert_eq!(n_iterations(2024, 2000), 8667524);
    }

    #[test]
    fn test_part_1_example() {
        assert_eq!(part_1(EXAMPLE_INPUT.lines()), 37327623);
    }

    #[test]
    fn test_part_1() {
        assert_eq!(part_1(load_input("inputs/2024/day_22").lines()), 18694566361);
    }

    #[test]
    fn test_part_2_example() {
        assert_eq!(part_2(EXAMPLE_INPUT_2.lines()), 23);
    }

    #[test]
    fn test_part_2() {
        assert_eq!(part_2(load_input("inputs/2024/day_22").lines()), 2100)
    }
}
